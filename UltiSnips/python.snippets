extends python

##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.



global !p

NORMAL  = 0x1
DOXYGEN = 0x2
RST = 0x3

import vim
def find_def_name(ident):

    cp = vim.eval('getpos(".")')

    # Find the nearest def
    vim.eval("searchpos('" + ident + "', 'b')")

    # Get the name of the def/method/etc.  
    vim.command('execute "normal W"')
    dname = vim.eval("expand('<cword>')")
    vim.command("call setpos('.', " + str(cp) + ")")

    return dname

def get_args(arglist):
    args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
    args = [arg for arg in args if arg and arg != "self"]

    return args


def get_style(snip):
    style = snip.opt("g:ultisnips_python_style", "normal")

    if    style == "doxygen": return DOXYGEN
    elif style == 'rst': return RST
    else: return NORMAL


def format_arg(arg, style, snip):
    if style == DOXYGEN:
        return "@param %s @todo" % arg
    elif style == RST:
        return (":param %s: arg description\n"
                "%s:type %s: type description") % (arg, snip.indent, arg)
    elif style == NORMAL:
        return ":%s: @todo" % arg


def format_return(style, snip):
    if style == DOXYGEN:
        return "@return: @todo"
    elif style == RST:
        return (":return:\n%s:rtype:") % snip
    elif style == NORMAL:
        return ":returns: @todo"


def write_docstring_args(args, snip):
    if not args:
        snip.rv += ' """'
        return

    snip += ""

    style = get_style(snip)

    for arg in args:
        snip += format_arg(arg, style, snip)


def write_init_body(cname, args, parents, snip):
    parents = [p.strip() for p in parents.split(",")]
    parents = [p for p in parents if p != 'object']

    if parents:
        arglist = ', '.join(args)
        snip += "super(" + cname + ", self).__init__(" + arglist + ")"
        snip += ""

    for arg in args:
        snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
    args = ['"%s"' % arg for arg in args]
    snip += '__slots__ = (%s,)' % ', '.join(args)

def get_arg_names(log_str):
    names = [log_str.split(':')[0].strip() for arg in log_str.split(',') if arg]
    return names

endglobal


# Ifs
snippet if "Simple if :"
if ${1:condition}:
    $0    
endsnippet

snippet el "Simple else:"
else:
    $0
endsnippet

snippet ei "Simple elif:"
elif ${1:condition}:
    $0
endsnippet

snippet pr "print()"
print($0)
endsnippet

snippet pra "print() with args"
print("${1}%s" % (${2},${3}))$0
endsnippet

snippet def "my function with docstrings" !b
def ${1:function}(`!p
if snip.indent:
   snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	"""${4:todo: Docstring for $1}`!p
snip.rv = ""
snip >> 1

args = get_args(t[2])
if args:
   write_docstring_args(args, snip)

style = get_style(snip)
snip += format_return(style, snip.indent)
snip += '"""' `

	${5:pass}
#$1()
endsnippet

snippet deft "my test function with docstrings" b
def test_${1:function}(self):
	"""${2:todo: Docstring for $1}"""
	${3:pass}
#test_$1()${0}
endsnippet

snippet logger "Add a named logging logger" b
import logging

# Set up the logger
logger = logging.getLogger(${1:__name__})
# Use a console handler, set it to debug by default
logger_ch = logging.StreamHandler()
logger.setLevel(logging.DEBUG)
log_formatter = logging.Formatter(('%(asctime)s %(levelname)s:%(process)s'
                                   ' %(lineno)s:%(module)s:%(funcName)s()'
                                   ' %(message)s'))
logger_ch.setFormatter(log_formatter)
logger.addHandler(logger_ch)${0}
endsnippet

snippet im "Import shortcut" b
import ${0}
endsnippet

snippet ima "Import as shortcut" b
import ${1} as ${0}
endsnippet

snippet fim "From pkg Import sub" b
from ${1} import ${0}
endsnippet

snippet for "For" b
for ${1} in ${2}:
    ${3}
# end for $1 in $2
${0}
endsnippet

#snippet if "if" b
#if ${1}:
#    ${0}
#endsnippet

snippet el "else" b
else ${1}:
    ${0}
endsnippet

snippet ifel "if else" b
if ${1}:
    ${2}
else ${3}:
    ${0}
endsnippet

snippet cl "class with docstrings" !b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""

	def __init__(self$4):
		"""${5:todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'


snip += ""
write_init_body(t[1], args, t[2], snip)
`
    #__init__()
		$0
#$1
endsnippet

snippet cln "class with nothing, it's naked" b
class ${1:MyClass}(${2:object}):
    ${3:pass}$0
#$1
endsnippet

snippet clt "unittest test case class with docstrings" b
class Test${1:TestClass}(unittest.TestCase):
	"""${3:Docstring for $1 }"""

	def setUp(self):
		"""${4:todo: to be defined}"""
        ${5:pass}
    #setUp()

    def test_${6}(self):
        ${7:pass}
    #$6()
		$0
#Test$1
endsnippet

snippet ldbg "logger.debug()"
logger.debug(${1})${0}
endsnippet

snippet lerr "logger.error()"
logger.error(${1})${0}
endsnippet

snippet lwrn "logger.warning()"
logger.warning(${1})${0}
endsnippet

snippet linf "logger.info()"
logger.info(${1})${0}
endsnippet

snippet prv "<self.>_varname = <value"
`!p
if snip.indent:
    snip.rv = 'self.'`_${1:varname} = ${2:value}${0}
endsnippet

# Django specific
snippet djm "Django model class with docstrings" b
class ${1:MyModel}(models.Model):
	"""${2:Docstring for $1 }"""

    ${0}

    def __unicode__(self):
        pass
#$1
endsnippet

snippet djf "Django model field member" b
${1:field_name} = models.${2:fieldType}(${3})${0}
endsnippet

snippet djv "Django view" b
${1:@render_to}
def ${2:view_name}(req${3:, kwargs})
    $0
#$2()
endsnippet


# snippet pa "Print arg 'arg: %s'" i
# ${1:arg}: %s`!p
# names = get_arg_names(t[1])
# snip.rv += names`${0}
# endsnippet

snippet pa "Print arg 'arg: %s'" i
${1:arg}: %s${0}
endsnippet

# Find the class name and method name and
# create a nice super call
snippet sup "super(Class, self)."
super(${1:`!p snip.rv += find_def_name("class ")`}, self).${2:`!p snip.rv += find_def_name("def ")`}(${3})${0}
endsnippet
#snippet sup "super(Class, self)."
#super(${1:`!v FindDefName("class ")`}, self).${2:`!v FindDefName("def ")`}(${3})${0}
#endsnippet

snippet optpar
from optparse import OptionParser

opt_parser = OptionParser(                                                                          
    usage=("usage: %prog Add your help message here.")
)     

# A basic option that sets an option variable to a string value
opt_parser.add_option("-c", "--config", dest="config_file",                 
        default="",                                           
        help=("The path to the config file for this"        
            " program"))   

# An example of a boolean option
opt_parser.add_option("-d", "--daemonize", dest="daemonize",                
        action="store_true", default=False,                   
        help=("Have the program service daemonize itself" )
)

# 'options' is an object that allows easy referencing of the
# parser options added above.
# Ex: To the the value of the '--config' option refercence: options.config_file
# 'args' is a list of arguments given that aren't part of the option switches
# defined above.
# Ex: If the command '$ command --config=/path/to/config start' is called
# Then args would look like: ['start']
(options, args) = opt_parser.parse_args()
endsnippet

snippet .fm "Python str.format()" !i
.format(${1})${0}
endsnippet

# vim:ft=snippets:
